# 刷题笔记

​	用于记录一些笔试面试的错题和相关知识点

[TOC]

## C/C++相关

### 常对象与常成员函数 

​	如果希望某个对象的值初始化以后就再也不被改变，则定义该对象时可以在前面加 const 关键字，使之成为常量对象（简称“常对象”）。常量对象一旦初始化后，其数据成员的值就再也不能更改。因此，**不能通过常量对象调用普通成员函数**，因为普通成员函数在执行过程中有可能修改对象的数据成员的值。但是可以通过常量对象调用常量成员函数。

​	所谓常量成员函数，就是在定义时加了const关键字的成员函数（声明和定义都需要加）。其不能更新对象的数据成员。同时常成员函数的const关键字可以被用于参与对重载函数的区分。（注意：加在函数前的const为返回值为一个常量，它（返回值）无法作为重载的条件）

```C++
class Sample
{
    public:
    void GetValue() const;	// 常成员函数
    void GetValue();
    void SetValue();
}
void Sample::GetValue() const
{}
void Sample::GetValue()
{}
void Sample::SetValue()
{}
int main()
{
    const Sample 0bj1;
    Sample Obj2;
    Obj1.GetVlaue();		// 常量对象上可以执行常量成员函数
    // Obj1.SetValue();		// 不管该函数中是否修改数据成员，编译器是无法通过的
    Obj2.GetVlaue();		// 它调用的是非常成员函数的重载
}
```

​	这里需要注意对于类中的静态成员变量，它存放在全局区，它属于类的全局变量，不属于某一个对象，所以常成员函数是可以修改对象中的静态成员变量的。

### C/C++的编译

​	C/C++的编译过程包括预编译、编译、汇编和链接

​	1、预编译：预处理器对c程序进行一些预处理工作，例如对宏定义的变量进行替换；
​		1）将所有的#define删除，并展开所有的宏定义；
​		2）处理所有的预编译指令，例如：#if,#elif,#else,#endif;
​		3）处理#include预编译指令，将被包含的文件插入到预编译指令的位置；
​		4）添加行号信息文件名信息，便于调试；
​		5）删除所有的注释：// /**/;
​		6）保留所有的#pragma编译指令，因为在编写程序的时候，我们经常要用到#pragma指令来设定编译器的状态或者是指示编译器完成一些特定的动作；
​		7）最后生成.i文件；
​		总的来说，包括（1）去注释 （2）宏替换 （3）头文件展开 （4）条件编译

​	2、编译：编译器将c语言程序翻译成汇编语言程序；
​		1）扫描，语法分析，语义分析，源代码优化，目标代码生成，目标代码优化；
​		2）生成汇编代码；
​		3）汇总符号；
​		4）生成.s文件；

​	3、汇编：汇编语言通过汇编器编译成可重定位目标程序.o，与之相反称为反汇编；
​		1）根据汇编指令和特定平台，把汇编指令翻译成二进制形式；
​		2）合并各个section，合并符号表；
​		3）生成.o文件；

​	4、链接：将目标文件和所需的库函数用链接器进行链接；
​		1）合并各个.obj文件的section，合并符号表，进行符号解析；
​		2）符号地址重定位；
​		3）生成可执行文件；

### sizeof

​	获取某个数据类型所占用空间的字节数。需要注意其获取指针的问题，对于32位机，指针返回值为4，64位机返回值为8。（一般来说32位机的地址总线长度为32位，64位机地址总线长度为64位）。

### 结构体的字节对齐

​		不同系统下的C语言类型长度

<img src="images/刷题笔记/image-20220330110332909.png" alt="image-20220330110332909" style="zoom: 67%;" />

​	绝大部分64位的Unix，linux都是使用的LP64模型；32位Linux系统是ILP32模型；64位的Windows使用的是LLP64(long long and point 64)模型。

​	**自身对齐值：**数据类型本身的对齐值，例如char类型的是1，short类型是2；结构体或者类的自身对齐值为其成员中自身对齐值最大的那个值；
​	**指定对齐值：**编译器或程序员指定的结构体对齐值，32位单片机的指定对齐值默认是4，VS默认值是8；
​	**有效对齐值：**自身对齐值和指定对齐值中较小的那个。

对齐有两个规则：

​	1、对于结构体或者类，要将其补齐为其有效对齐值的整数倍。
​	2、存放成员的起始地址必须是该成员有效对齐值的整数倍。

```C++
// 默认字节对齐值为4
// 4字节
typedef struct A{
    char a;
    char b;
    char c;
    char d;}structA;

// 6字节，结构体的有效对齐值为2字节，
// 0x0 0x1 0x2 0x3 0x4 0x5
//  a   x   b   b   c   d
typedef struct B{
    char a;
    short b;
    char c;
    char d;}structB;

// 12字节，结构体的有效对齐值为4字节，
// 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xA 0xB
//  a   x   x   x   b   b   b   b   c   d   x   x  
typedef struct C{
    char a;
    int b;
    char c;
    char d;}structC;

// 20字节，结构体的有效对齐值为4字节
// 0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xA 0xB 0xC 0xD 0xE 0xF 0x10 0x11 0x12 0x13
//  a   x   x   x   b   b   b   b   b   b   b   b   c   c   c   c   d    x    x    x
// 若指定对齐值为8，则占24字节
typedef struct D{
    char a;
    double b;
    int c;
    char d;}structD;
```

### volatile 关键字

​	volatile 关键字提醒编译器定义的变量是易变的，编译后的程序每次需要存储或读取该变量时，会直接从变量地址读取数据。在中断或多线程中使用volatile关键字可以避免不同优化等级时程序出错，提高程序的鲁棒性。

### 内存分区

​	C++程序在执行时，将内存大方向划分为**4个区域**

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和静态变量以及常量
- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

​	栈区和堆区的区别：从申请方式，申请大小，申请效率简单比较；Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。Stack空间有限，Heap是很大的自由存储区。Stack申请效率高，Heap申请效率低。

### 大端小端

​	大端存储格式就是自数据的高字节存放在低地址中，低字节存放在高地址中。例如0x12345678

<img src="images/刷题笔记/image-20220330202533465.png" alt="image-20220330202533465" style="zoom:50%;" />

而小端存储格式即高地址存放字数据的高地址数据，低字节就存放字数据的低地址数据。

<img src="images/刷题笔记/image-20220330202601460.png" alt="image-20220330202601460" style="zoom:50%;" />

比如x86的是小端模式，KEIL C51是大端模式。

```C++
union Student{
     int  i;
     unsigned char ch[2];
}
int main()
{
    Student student;
    student.i=0x1420;
    // 假设起始地址为0x00
    // 小端模式，输出为 32 20
    // 地址 0x00 0x01 0x02 0x03
    // 数据 0x20 0x14 0x00 0x00
    // 大端模式，输出为 0 0
    // 地址 0x00 0x01 0x02 0x03
    // 数据 0x00 0x00 0x14 0x20
    printf("%d %d",student.ch[0],ch[1]);
    return 0;
}
```

### 浮点数格式

​	绝大多数现代的计算机系统采纳了所谓的浮点数表达方式。计算机对浮点数的表示规范遵循电气和电子工程师协会（IEEE）推出的 IEEE754 标准， 这种表达方式利用科学计数法来表达实数，即用一个尾数（Mantissa ）， 一个基数（Base），一个指数(也叫阶码)（Exponent）以及一个表示正负的符号(Sign)来表达实数。 比如 123.45 用十进制科学计数法可以表达为 1.2345 × 10^2 ，其中 1.2345 为尾数，10 为基数，2 为指数。 浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。 又对于一个二进制的数比如1011.01，用科学计数法也可以表示为：1.01101*2^3，其中 1.1101为尾数，2为基数，3为指数。

​	**注意**，IEE754 规定浮点数阶码 E 采用"**指数ｅ的移码-1**"来表示，请记住这一点。为什么指数移码要减去 1，这是 IEEE754 对阶码的特殊要求，以满足特殊情况，比如对正无穷的表示。移码（又叫增码）是对真值**补码**的**符号位**取反，一般用作浮点数的阶码，引入的目的是便于浮点数运算时的对阶操作。
$$
[X]_移 = 2^{n - 1} + X
$$
<img src="images/刷题笔记/image-20220330210209941.png" alt="image-20220330210209941" style="zoom:67%;" />

​	IEEE754 标准中，32位浮点数的阶码为8位，一个规格化的32位浮点数 x 的真值表示为：
$$
x = (-1)^S \times (1.M) \times 2^e \\
[e]_移 = E + 1 \\
[e]_移 = 2^{8 - 1} + e \\
e = E - 127
$$
​	64位浮点数的阶码为11位，一个规格化的64位浮点数 x 的真值表示为：
$$
x = (-1)^S \times (1.M) \times 2^e \\
[e]_移 = E + 1 \\
[e]_移 = 2^{11 - 1} + e \\
e = E - 1023
$$
**十进制到机器码**

​	$1.5 = [1.1]_2$，符号位为0，指数$e = 0$，规格化后尾数为1.1。

​	尾数域Ｍ右侧以0补全，得尾数域：
$$
M = [100 0000 0000 0000 0000 0000]_2
$$
​	阶码E：
$$
E = [0]_移 - 1 = [1000 0000]_2 - 1 = [0111 1111]_2
$$
​	得1.5的机器码：
$$
1.5 = [0011 1111 1100 0000 0000 0000 0000 0000]_2 = 0x3FC00000
$$
**取值范围**

​	float的最大正数：
$$
PosMax = (−1)^S  × 1.M × 2^e = +(1.11111111111111111111111) × 2^{127}  ≈ 3.402823e+38
$$
​	最小正数：
$$
PosMin = (−1)^S  × 1.M × 2^e = +(1.0) × 2^{-126}  ≈ 1.175494e−38
$$
​	最大负数：
$$
NegMax = (−1)^S  × 1.M × 2^e = -(1.0) × 2^{-126}  ≈ −1.175494e−38
$$
​	最小负数：
$$
NegMin = (−1)^S  × 1.M × 2^e = -(1.11111111111111111111111) × 2^{127}  ≈ -3.402823e+38
$$
**特殊情况**

（1）0 的表示

​	对于阶码为 0 或 255 的情况，IEEE754 标准有特别的规定：如果 阶码 E=0 并且尾数 M 是 0，则这个数的真值为 ±0（正负号和数符位有关）。因此 +0 的机器码为：0 00000000 000 0000 0000 0000 0000 0000。-0 的机器码为：1 00000000 000 0000 0000 0000 0000 0000。需要注意一点，浮点数不能精确表示 0，而是以很小的数来近似表示 0，因为浮点数的真值等于（以32bits单精度浮点数为例）$±1.0 \times 2^{-127}$

（2）$+\infty$和$-\infty$ 的表示
	如果阶码 E=255 并且尾数 M 全是0，则这个数的真值为 $±\infty$（同样和符号位有关）。

（3）NaN（Not a Number）
	如果 E = 255 并且 M 不是0，则这不是一个数（NaN）。

### 只能使用new创建的对象

​	将析构函数设为私有，则无法静态创建对象，因为静态创建是由编译器管理对象的生命周期，而将析构函数设为私有，则类外部无法调用它，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了。

​	只能通过new来创建，但是类中必须提供一个destory函数来进行内存空间的释放，因为delete函数默认会调用析构函数释放空间，而析构函数为私有，无法调用。

​	这个[博客](https://www.cnblogs.com/ahuangliang/archive/2004/07/17/5309279.html)里面有使用友元类包装实现静态创建的方法。

### do{...}while(0)

​	1.**辅助定义复杂的宏，避免引用的时候出错**：使用do{...}while(0)把它包裹起来，成为一个独立的语法单元，从而不会与上下文发生混淆。同时因为绝大多数的编译器都能够识别do{...}while(0)这种无用的循环并进行优化，所以使用这种方法也不会导致程序的性能降低。

​	2.**避免使用goto对程序流进行统一的控制**：有些函数中，在函数return之前我们经常会进行一些收尾的工作，比如free掉一块函数开始malloc的内存，goto一直都是一个比较简便的方法。由于goto不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，那这个时候就可以用do{}while(0)来进行统一的管理.

```C++
// goto
int foo()
{
    somestruct* ptr = malloc(...);
    dosomething...;
    if(error){
        goto END;
    }
    dosomething...;
    if(error){
        goto END;
    }
    dosomething...;
END:
    free(ptr);
    return 0;
}

// do{}while(0)
int foo()
{
    somestruct* ptr = malloc(...);
    do{
        dosomething...;
        if(error){
            break;
        }
        dosomething...;
        if(error){
            break;
        }
        dosomething...;
    }while(0);
    free(ptr);
    return 0;
}
```

​	3.**避免空宏引起的warning**：内核中由于不同架构的限制，很多时候会用到空宏，在编译的时候，空宏会给出warning，为了避免这样的warning，就可以使用do{}while(0)来定义空宏，如`#define EMPTYMICRO do{}while(0)`。



## 算法相关

### 二进制数中1的个数

```c++
int function(x)  {
    int flag = 0;
    while(x)  {
          x = x&(x-1);
          flag ++;
     }
    return flag ;
}
```







## 嵌入式相关





## 硬件相关





## 计算机网络相关





## 计算机组成相关





## 汇编相关



