# 操作系统

​	主要参考[哈工大李治军老师的《操作系统》的慕课](https://www.bilibili.com/video/BV1d4411v7u7?p=1)。

[TOC]

## 0. 汇编基础知识

### 0.1 寄存器相关

​	8086CPU中寄存器总共有14个，都是16位的。即**AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES** 共 14 个。其中AX，BX，CX，DX，SP，BP，SI，DI都是通用寄存器。

​	**数据寄存器：**

​		AX (Accumulator)：累加寄存器，也称之为累加器；

​		BX (Base)：基地址寄存器；

​		CX (Count)：计数器寄存器；

​		DX (Data)：数据寄存器；

​	**指针寄存器：**

​		SP (Stack Pointer)：堆栈指针寄存器；

​		BP (Base Pointer)：基指针寄存器；

​	**变址寄存器：**

​		SI (Source Index)：源变址寄存器；

​		DI (Destination Index)：目的变址寄存器；

​	**控制寄存器：**

​		IP (Instruction Pointer)：指令指针寄存器；

​		FLAG：标志寄存器；

​	**段寄存器：**

​		CS (Code Segment)：代码段寄存器；

​		DS (Data Segment)：数据段寄存器；

​		SS (Stack Segment)：堆栈段寄存器；

​		ES (Extra Segment)：附加段寄存器；

#### 数据寄存器（AX，BX，CX，DX）

​	数据寄存器有 AX，BX，CX，DX 四个组成，由于在 8086 之前的 CPU 为 8 位 CPU，所以为了兼容以前的 8 位程序，在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用，由此，每一个 16 位寄存器就可以当做 2 个独立的 8 位寄存器来使用了 。 

​	**AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器；**

​	**BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器；**

​	**CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器；**

​	**DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器；**

​	AH 和 AL 作为 8 位寄存器使用时，可以看做它们是互不相关的，也就是看做两个完全没有联系的寄存器 X 和 Y 即可。

**AX寄存器**

​	AX 的另外一个名字叫做累加寄存器或者简称为累加器，是编程中用的最多、最频繁的寄存器。其可以作为普通的寄存器用来存放16位或者8位的数据。

​	AX 寄存器还具有的特殊用途是在使用 DIV 和 MUL 指令时使用。

​	DIV 在 8086 CPU 中是除法指令，而在使用除法的时候有两种情况，即除数可以是 8 位或者是 16 位的，而且除数可以存放在寄存器中或者是内存单元中，而至于**被除数**的话，由 AX 来存放了。如果被除数一定会是 16 位的，并且默认是放在 AX 寄存器中，被除数是 32 位时， DX 存放 32 位的被除数的高 16 位，而 AX 则存放 32 位的被除数的低 16 位；同时，AX 的作用存放除法的计算结果，则在 AL 中会保存此次除法操作的商，而在 AH 中则会保存此次除法操作的余数，当然，如果除数是 16 位的话，则 AX 中会保存本次除法操作的商，而 DX 则保存本次除法操作的余数。

​	当使用 MUL 做乘法运算时，两个相乘的数要么都是 8 位，要么都是 16 位，如果两个相乘的数都是 8 位的话，则一个默认是放在 AL 中，而另一个 8 位的乘数则位于其他的寄存器或者说是内存字节单元中；而如果两个相乘的数都是 16 位的话，则一个默认存放在 AX 中，另一个 16 位的则是位于 16 的寄存器中或者是某个内存字单元中。同时，当 MUL 指令执行完毕后，如果是 8 位的乘法运算，则默认乘法运算的结果是保存在 AX 中，而如果是 16 位的乘法运算的话，则默认乘法运算的结果有 32 位，其中，高位默认保存在 DX 中，而低位则默认保存在 AX 中。

**BX寄存器**

​	BX 作为数据寄存器，表明其是可以暂存一般的16位或者8位数据。其也称为**基址寄存器或基地址指针**，用来存放偏移地址，其默认的段地址为DS。

```assembly
MOV AH,[BX]		;设置 AH 的值为偏移地址为 DS:BX 中的值时所代表的内存单元
```

**CX寄存器**

​	CX寄存器除了存放数据外，还称为计数寄存器，在循环操作是做计数器用，用于控制循环程序的执行次数。

**DX寄存器**

​	DX寄存器可以作为普通寄存器来存放数据，在乘法、除法和I/O端口操作中有专门用途，关于乘除法操作在AX寄存器中有详细介绍。

#### 指针寄存器（BP，SP）

**BP寄存器**

​	BP（Base Pointer）也就是基指针寄存器，它和其他的几个用来进行寻址操作所使用的寄存器（还有 BX，SI，DI）没有太大的区别，首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用；其默认的段寄存器为SS。**在 8086 CPU 中，只有 4 个寄存器可以以 […] 的方式使用，这四个寄存器分别是 BX，SI，DI，BP。**

```assembly
MOV AX,[BP]         ;将 SS:[BP] 代表的内存单元移入 AX 中
MOV AX,CS:[BP]      ;将 CS:[BP] 代表的内存单元移入 AX 中
```

**SP寄存器**

​	SP（Stack Pointer）堆栈指针寄存器，其内容为栈顶的偏移地址。它也是通用寄存器的一种，与BP类似，是可以暂存数据的。==这里就有一个疑问，详细看后面关于SS的部分。==

#### 变址寄存器（SI，DI）

​	SI (Source Index) 是源变址寄存器，DI (Destination Index) 即是目的变址寄存器，8086 CPU 中的 SI 寄存器和 DI 寄存器其实和 BX 寄存器的功能是差不多的，只不过 SI 寄存器和 DI 寄存器均不是数据寄存器，所以它们不能够拆分为 2 个独立的 8 位寄存器，而这也就是 SI 寄存器和 DI 寄存器与BX 寄存器所不同的地方，既然，SI，DI 两个寄存器的功能和 BX 差不多，自然，SI 和 DI 中也是可以暂存一般性数据的，同时，通过使用 SI 和 DI 寄存器也是可以用来完成寻址操作的。其默认的段寄存器为DS。

```assembly
MOV AX,[SI]		;将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中
MOV AX,SS:[SI]		;将段地址为 SS 偏移地址为 SI 的内存单元中的值移入 AX 中

MOV AX,[DI]		;将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中
MOV AX,SS:[DI]		;将段地址为 SS 偏移地址为 DI 的内存单元中的值移入 AX 中
```

#### 其他寄存器

​	当 CPU 在访问内存时，其会使用一个 16 位的基地址，然后再使用一个 16 位的偏移地址，通过将基地址和偏移地址传入 8086 CPU 的地址加法器中进行合成即可以构造出 20 位的物理地址。在编程时，可以将一段内存定义成为一个段，而这里，我们又可以分为数据段，代码段，栈段这三种类型的段 。

**CS和IP寄存器**

​	CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 CS 为代码段寄存器，而  IP 为指令指针寄存器 。指令地址为`CS << 4 + IP`。

**SS 和 SP 寄存器**

​	对于栈顶的段地址，其是存放在段寄存器 SS 中的，而对于栈顶的偏移地址，其则是存放在 SP 寄存器中的 ，**在任何时刻，SS:SP 都是指向栈顶元素 。**但是SP又是一个可以用来存放数据的通用寄存器，所以感觉很少会用它来暂存数据，如果需要用它暂存数据，那就不能操作栈了，应该只有一些特殊用途才会用它存放数据。

​	要注意的是 8086 CPU 并不会保证我们对栈的操作会不会越界 。

**DS寄存器和ES寄存器**

​	DS 寄存器和 ES 寄存器都属于段寄存器，其实它们和 CS 寄存器以及 SS 寄存器用起来区别不大。

​	DS（Data Segment）数据段寄存器用来存放数据段的段地址 。BX，SI，DI的默认段寄存器都是DS。

​	 ES（Extra Segment） 附加段寄存器，可以把它是个扩展，如果之前的段寄存器不够用的时候，你可以考虑使用  ES 段寄存器，在使用方式上，则和其他的段寄存器没什么区别 。

**标志寄存器**

​	16位标志寄存器flags用来存放运算结果的特征。flag寄存器中存储的信息通常又被称作程序状态字（PSW）。

<img src="images/操作系统/image-20220327143432927.png" alt="image-20220327143432927" style="zoom:67%;" />

### 0.2 8086寻址方式

#### 立即寻址方式

​	在立即寻址(Immediate Addressing)方式下，操作数直接包含在指令中，它是一个8位或16位的常数，也叫立即数。这类指令翻译成机器码时，立即数作为指令的一部分，紧跟在操作码之后，存放在代码段内。如果立即数是16位数，则高字节存放在代码段的高地址单元中，低字节放在低地址单元中。立即寻址方式的指令常用来给寄存器赋初值。

```assembly
MOV	AL, 26H
MOV CX, 2A50H
```

#### 寄存器寻址方式

​	在寄存器寻址(Register Addressing)方式下，操作数包含在寄存器中，由指令指定寄存器的名称。对于16位操作数，寄存器可以是AX、BX、CX、DX、SI、DI、SP和BP等。对于8位操作数，则用寄存器AH、AL、BH、BL、CH、CL、DH和DL。源操作数的长度必须与目的操作数一致，否则会出错。

```assembly
MOV DX, AX
MOV CL, AH
```

#### 直接寻址方式

**直接寻址方式**

​	在PC机中，把操作数的偏移地址称为有效地址EA(Effective Address)。使用直接寻址(Direct Addressing)方式的指令时，存储单元的有效地址直接由指令给出，在它们的机器码中，有效地址存放在代码段中指令的操作码之后。当采用直接寻址指令时，如果指令中没有用前缀指明操作数存放在哪一段，则默认为使用的段寄存器为数据段寄存器DS。

```assembly
;操作数的物理地址 = DS << 4 + EA\
;指令中有效地址必须加一个方括号
MOV	AX, [2000H]	;若DS = 3000H，则物理地址为3000H << 4 + 2000H = 32000H，CPU将从32000H的内存中取出操作数
```

**段超越前缀**

​	如果要对代码段、堆栈段或附加段寄存器所指出的存储区进行直接寻址，应在指令中指
定段超越前缀。

```assembly
MOV AX, ES:[500H]
```

#### 寄存器间接寻址方式

​	指令中给出的寄存器中的值不是操作数本身，而是操作数的有效地址，这种寻址方式称为寄存器间接寻址(Register Indirect Addressing)。寄存器名称外面必须加方括号，以与寄存器寻址方式相区别。这类指令中使用的寄存器有基址寄存器BX、BP及变址寄存器SI、DI。

```assembly
MOV AX, [BX]	;从DS << 4 + BX的内存单元去操作数放入AX中
MOV CX, ES:[SI]	;从ES << 4 + SI的内存单元去操作数放入AX中
```

#### 寄存器相对寻址方式

​	操作数的有效地址是一个基址或变址寄存器的内容与指令中指定的8位或16位位移量(Displacement)之和。这种寄存器相对寻址(Register Relative Addressing)方式与寄存器间接寻址十分相似，主要区别是前者在有效地址上还要加一个位移量。

```assembly
MOV	BX, COUNT[SI]	;物理地址为 DS << 4 + SI + COUNT
```

#### 基址变址寻址方式

​	基址变址寻址(Based Indexed Addressing)方式的操作数的有效地址是一个基址寄存器（BX或BP）和一个变址寄存器(SI或DI)的内容之和，两个寄存器均由指令指定。

```assembly
MOV	AX, [BX][SI]	;物理地址为 DS << 4 + BX + SI
```

#### 相对基址变址寻址方式

​	相对基址变址寻址（Relative Based Indexed Addressing）方式的操作数的有效地址是一个基址寄存器和一个变址寄存器的内容，再加上指令中指定的8位或16位位移量之和。

```assembly
MOV	AX, 200H[BX][SI]	;物理地址为 DS << 4 + 200H + BX + SI
```

### 进程

​	进程



### 线程

​	线程

### 信号量

​	信号量

### 内存使用和分段

​	

​	

